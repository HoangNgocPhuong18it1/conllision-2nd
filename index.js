/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./circle.js":
/*!*******************!*\
  !*** ./circle.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CircleNew\": () => (/* binding */ CircleNew)\n/* harmony export */ });\n/* harmony import */ var _gameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gameObject */ \"./gameObject.js\");\n\r\nclass CircleNew extends _gameObject__WEBPACK_IMPORTED_MODULE_0__.GameObjectNew\r\n{   \r\n    constructor (context, vtx, vx, vy,radius){\r\n        super(context, vtx, vx, vy,radius);\r\n        // Set default width and height\r\n        this.vtx= vtx;\r\n        this.mass = this.radius/2;\r\n        this.degreesold = 180 *(Math.atan2(this.vy, this.vx))/ Math.PI\r\n        this.restitution2 = 1.1; \r\n        this.lineX = 0;\r\n        this.lineY = 0;\r\n    }\r\n    draw(){\r\n        // // Draw a simple Circle\r\n        this.context.fillStyle = this.isColliding?'#ff8080':'#0099b0';\r\n        this.context.beginPath();\r\n        // this.context.fillRect(this.x, this.y, this.width, this.height);\r\n        this.context.arc(this.vtx.x, this.vtx.y, this.radius, 0, 2 * Math.PI);\r\n        this.context.fill();\r\n        // this.context.drawImage(img, this.x - this.radius*1.2, this.y - this.radius * 1.1, this.radius * 2.5, this.radius * 2.62);\r\n        this.context.beginPath();\r\n        this.context.moveTo(this.vtx.x, this.vtx.y);\r\n        this.context.lineTo(this.lineX,this.lineY);\r\n        this.context.stroke();\r\n    }\r\n   \r\n\r\n    update(secondsPassed){\r\n        // Move with set velocity\r\n        // this.vy += g * secondsPassed;\r\n        this.vtx.x += this.vx * secondsPassed;\r\n        this.vtx.y += this.vy * secondsPassed;\r\n        // Calculate the angle (vy before vx)\r\n        let radians = Math.atan2(this.vy, this.vx);\r\n        // Convert to degrees\r\n        let degrees = 180 * radians / Math.PI;\r\n        // console.log(\"số:\",degrees)\r\n        this.lineY = this.vtx.y + (Math.sin(radians) * this.radius);\r\n        this.lineX = this.vtx.x + (Math.cos(radians) * this.radius);\r\n        this.isColliding = false;\r\n       \r\n    }\r\n    clearCanvas(){\r\n        this.context.clearRect(0, 0, 500,  500);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://newcollision/./circle.js?");

/***/ }),

/***/ "./coordinates.js":
/*!************************!*\
  !*** ./coordinates.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Coordinates\": () => (/* binding */ Coordinates)\n/* harmony export */ });\nclass Coordinates{\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        \r\n    }\r\n    \r\n}\r\n\n\n//# sourceURL=webpack://newcollision/./coordinates.js?");

/***/ }),

/***/ "./function.js":
/*!*********************!*\
  !*** ./function.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circle */ \"./circle.js\");\n/* harmony import */ var _polygons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polygons */ \"./polygons.js\");\n/* harmony import */ var _coordinates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coordinates */ \"./coordinates.js\");\n\r\n\r\n\r\n\r\nlet canvas ;\r\nconst canvasWidth = 500;\r\nconst canvasHeight = 500;\r\nlet context;\r\n\r\nlet circle;\r\n\r\nlet polygonsObjects;\r\n\r\nlet lastFrameTimeMs =  0,  \r\n    maxFPS =  75 ; \r\nvar fps =  60 , \r\n    framesThisSecond =  0 , \r\n    lastFpsUpdate =  0 ; \r\n\r\n    \r\nlet timestep =  1/60 ; \r\nlet delta =0;\r\n\r\n\r\nlet squareWidth = 100;\r\nconst g = 9.81;\r\nconst restitution = 1;\r\n\r\nlet pointG;\r\nwindow.onload = init;\r\nfunction init() {\r\n    canvas = document.getElementById('myCanvas');\r\n    context = canvas.getContext('2d');\r\n    circle = new _circle__WEBPACK_IMPORTED_MODULE_0__.CircleNew(context, new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(150, 200), 100, -60 ,30);\r\n    createPolygons();\r\n    pointG = new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(0,0);\r\n    window.requestAnimationFrame(gameLoop);\r\n}\r\nfunction createPolygons() {\r\n    polygonsObjects = [\r\n        new _polygons__WEBPACK_IMPORTED_MODULE_1__.Polygons(context, [new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(0, 100), new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(50, 150), new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(50, 50)] ,-100, 150 ),\r\n        new _polygons__WEBPACK_IMPORTED_MODULE_1__.Polygons(context, [new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(350, 10), new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(450, 10), new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(450, 110), new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(350, 110),  new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(300, 55)] ,100, 150),\r\n        new _polygons__WEBPACK_IMPORTED_MODULE_1__.Polygons(context, [new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(150, 10), new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(250, 10),  new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(150, 110),  new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(100, 55)] ,300, -150)\r\n    ]\r\n}\r\nfunction gameLoop(timeStamp) {\r\n    if (timeStamp < lastFrameTimeMs + (1000 / maxFPS)) {\r\n        requestAnimationFrame(gameLoop);\r\n        return;\r\n    }\r\n    delta +=  (timeStamp - lastFrameTimeMs )/1000;  // note + = here \r\n    lastFrameTimeMs = timeStamp ; \r\n    // console.log(delta , timestep)\r\n    var numUpdateSteps = 0;\r\n    while( delta >= timestep )  {\r\n        for (let i = 0; i < polygonsObjects.length; i++) {\r\n            pointG = findG(polygonsObjects[i].vtx);\r\n            \r\n            polygonsObjects[i].update(timestep, pointG);\r\n        }\r\n\r\n        circle.update(timestep);\r\n        delta -= timestep ; \r\n        if (++numUpdateSteps >= 240) {\r\n            panic();\r\n            break;\r\n        }\r\n    }\r\n    if (timeStamp > lastFpsUpdate + 1000) { \r\n        fps = 0.25 * framesThisSecond + (1 - 0.25) * fps; \r\n \r\n        lastFpsUpdate = timeStamp;\r\n        framesThisSecond = 0;\r\n    }\r\n    framesThisSecond++; \r\n    \r\n    \r\n\r\n    detectEdgeCollisions();\r\n    detectCollisionsPolygons();\r\n    detectCollisions();\r\n\r\n\r\n    // circle.clearCanvas();\r\n    // for (let i = 0; i < polygonsObjects.length; i++) {\r\n    //     polygonsObjects[i].clearCanvas();\r\n    //  }\r\n    context.clearRect(0, 0, 500,  500);\r\n\r\n    circle.draw();\r\n    for (let i = 0; i < polygonsObjects.length; i++) {\r\n        polygonsObjects[i].draw();\r\n     }\r\n    drawFps();\r\n   \r\n\r\n    window.requestAnimationFrame(gameLoop);\r\n}\r\nfunction panic() {\r\n    delta = 0;\r\n}\r\nfunction drawFps() {\r\n    context.beginPath();\r\n    context.font = \"16px Arial\";\r\n    context.fillStyle = \"#0095DD\";\r\n    context.fillText(\"FPS: \" + Math.round(fps), 420, 20);\r\n    \r\n}\r\n\r\nfunction detectCollisions(){\r\n    let objCircle;\r\n    let objPolygons;\r\n   \r\n    objCircle = circle;\r\n    \r\n    // let radians = Math.atan2(objCircle.vy, objCircle.vx);\r\n    // let dobjx1 = (Math.cos(radians) * objCircle.radius);\r\n    // let dobjy1 = (Math.sin(radians) * objCircle.radius);\r\n\r\n    let minDist = Number.MAX_VALUE;\r\n    let closestDelta = null;\r\n    let axis = null;\r\n    let poidd= new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(0,0);\r\n    for (let i = 0; i < polygonsObjects.length; i++) {\r\n        objPolygons = polygonsObjects[i];\r\n            poidd= findG(objPolygons.vtx);\r\n            if (detectCollisionsCircle(objCircle, objPolygons)) {\r\n\r\n                objCircle.vx = - objCircle.vx\r\n                objCircle.vy = -objCircle.vy\r\n\r\n                objPolygons.vx =  -objPolygons.vx\r\n                objPolygons.vy = - objPolygons.vy\r\n                \r\n                // let vCollision = {x: poidd.x - objCircle.x, y: poidd.y - objCircle.y};\r\n                // let distance = Math.sqrt((poidd.x-objCircle.x)*(poidd.x-objCircle.x) + (poidd.y-objCircle.y)*(poidd.y-objCircle.y));\r\n                // let vCollisionNorm = {x: vCollision.x / distance, y: vCollision.y / distance};\r\n                // let vRelativeVelocity = {x: objCircle.vx - objPolygons.vx, y: objCircle.vy - objPolygons.vy};\r\n                // let speed = vRelativeVelocity.x * vCollisionNorm.x + vRelativeVelocity.y * vCollisionNorm.y;\r\n                // objCircle.vx -= (speed * vCollisionNorm.x);\r\n                // objCircle.vy -= (speed * vCollisionNorm.y);\r\n                // objPolygons.vx += (speed * vCollisionNorm.x);\r\n                // objPolygons.vy += (speed * vCollisionNorm.y);\r\n\r\n                objCircle.isColliding = true;\r\n                objPolygons.isColliding = true;\r\n                // console.log(\"chạm tròn\")\r\n            }\r\n            // console.log(poidd.x , \" ||||\", objPolygons.G.x )\r\n    }\r\n    \r\n}\r\n\r\nfunction detectCollisionsCircle(objCircle , objPolygons) {\r\n\r\n    let result = false;\r\n    let vector = new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(0, 0);\r\n    let vLength = 0;\r\n    let projectVector = new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(0, 0);\r\n    let projectPoint = new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(0, 0);\r\n    let edgeVector;\r\n    let dotTmp;\r\n    let eLength = 0;\r\n   \r\n\r\n        objPolygons.vtx.forEach( (vertex, index) => {\r\n        vector.x = objCircle.vtx.x - vertex.x;\r\n        vector.y = objCircle.vtx.y - vertex.y;\r\n\r\n        vLength = doLonVector(vector);\r\n        eLength = doLonVector(objPolygons.edge[index]);\r\n\r\n        if( vLength < objCircle.radius){\r\n            result = true;\r\n        }\r\n\r\n        edgeVector = objPolygons.edge[index]\r\n        dotTmp = vectorDotProduct(vector, edgeVector) / vectorDotProduct(edgeVector, edgeVector);                \r\n        projectVector.x = edgeVector.x*dotTmp;\r\n        projectVector.y = edgeVector.y*dotTmp;\r\n\r\n        projectPoint.x = projectVector.x + vertex.x;\r\n        projectPoint.y = projectVector.y + vertex.y;\r\n\r\n        if(doLonVector(projectPoint, objCircle.vtx) < objCircle.radius){\r\n            if(index <objPolygons.vtx.length - 1){\r\n                if(doLonVector(projectPoint, vertex) < eLength\r\n                    && doLonVector(projectPoint, objPolygons.vtx[index+1]) < eLength)\r\n                    result = true;\r\n            }\r\n            else{\r\n                if(doLonVector(projectPoint, vertex) < eLength\r\n                    && doLonVector(projectPoint, objPolygons.vtx[0]) < eLength)\r\n                    result = true;\r\n            }\r\n                \r\n        }\r\n        \r\n    });\r\n    return result;\r\n}\r\nfunction doLonVector(vertex1, vertex2 = null) {\r\n    if(vertex2 === null)\r\n        return Math.sqrt(vertex1.x**2+vertex1.y**2);\r\n    return Math.sqrt((vertex1.x-vertex2.x)**2 + (vertex1.y-vertex2.y)**2)\r\n\r\n}\r\nfunction vectorDotProduct(vertex1, vertex2) {\r\n    return  (vertex1.x * vertex2.x) + (vertex1.y * vertex2.y);\r\n}\r\n\r\nfunction detectCollisionsPolygons() {\r\n    let obj1;\r\n    let obj2;\r\n    for (let i = 0; i < polygonsObjects.length; i++) {\r\n        obj1 = polygonsObjects[i];\r\n        for (let j =i+1; j < polygonsObjects.length; j++) {\r\n            obj2 = polygonsObjects[j];\r\n                // console.log(obj2.min);\r\n            // console.log(obj2.max)\r\n            // Check for left and right\r\n            if (sat(obj1 , obj2)) {\r\n                obj1.vx = - obj1.vx\r\n                obj1.vy = -obj1.vy\r\n\r\n                obj2.vx =  -obj2.vx\r\n                obj2.vy = - obj2.vy\r\n                obj1.isColliding = true;\r\n                obj2.isColliding = true;\r\n                console.log(\"đa giác chạm đa giác\")\r\n            }\r\n            // if (obj1.max.x > obj2.min.x && obj1.min.x <obj2.max.x && obj1.max.y > obj2.min.y && obj1.min.y < obj2.max.y) {\r\n            //     // if (objCircle.x < obj2.vtx.x + 100 && objCircle.x > obj2.vtx.x) {\r\n            //     //     objCircle.isColliding = true;\r\n            //     //     obj2.vtx.isColliding = true;\r\n            //     //     console.log(\"chạm \")\r\n            //     // }\r\n                \r\n            //     // let vCollision = {x: obj2.vtx.x - obj1.vtx.x, y: obj2.vtx.y - obj1.vtx.y};\r\n            //     // let distance = Math.sqrt((obj2.vtx.x-obj1.vtx.x)*(obj2.vtx.x-obj1.vtx.x) + (obj2.vtx.y-obj1.vtx.y)*(obj2.vtx.y-obj1.vtx.y));\r\n            //     // let vCollisionNorm = {x: vCollision.x / distance, y: vCollision.y / distance};\r\n            //     // let vRelativeVelocity = {x: obj1.vx - obj2.vx, y: obj1.vy - obj2.vy};\r\n            //     // let speed = vRelativeVelocity.x * vCollisionNorm.x + vRelativeVelocity.y * vCollisionNorm.y;\r\n            //     // obj1.vx -= (speed * vCollisionNorm.x);\r\n            //     // obj1.vy -= (speed * vCollisionNorm.y);\r\n            //     // obj2.vx += (speed * vCollisionNorm.x);\r\n            //     // obj2.vy += (speed * vCollisionNorm.y);\r\n                \r\n            \r\n            // }\r\n        }\r\n        \r\n    }\r\n}\r\n\r\nfunction sat(polygonA , polygonB) {\r\n    var perpendicularLine = null;\r\n    var dot = 0;\r\n    var perpendicularStack = [];\r\n    var amin = null;\r\n    var amax = null;\r\n    var bmin = null;\r\n    var bmax = null;\r\n    for(var i = 0;  i < polygonA.edge.length;  i++){\r\n        perpendicularLine = new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(-polygonA.edge[i].y,\r\n                                    polygonA.edge[i].x);\r\n        perpendicularStack.push(perpendicularLine);\r\n    }\r\n    for(var i = 0;  i < polygonB.edge.length;  i++){\r\n        perpendicularLine = new _coordinates__WEBPACK_IMPORTED_MODULE_2__.Coordinates(-polygonB.edge[i].y,\r\n                                    polygonB.edge[i].x);\r\n        perpendicularStack.push(perpendicularLine);\r\n        for(var i = 0; i < perpendicularStack.length; i++){\r\n            amin = null;\r\n            amax = null;\r\n            bmin = null;\r\n            bmax = null;\r\n            for(var j = 0; j < polygonA.vtx.length; j++){\r\n                dot = polygonA.vtx[j].x *\r\n                    perpendicularStack[i].x +\r\n                    polygonA.vtx[j].y *\r\n                    perpendicularStack[i].y;\r\n                if(amax === null || dot > amax){\r\n                    amax = dot;\r\n                }\r\n                if(amin === null || dot < amin){\r\n                    amin = dot;\r\n                }\r\n            }\r\n            for(var j = 0; j < polygonB.vtx.length; j++){\r\n                dot = polygonB.vtx[j].x *\r\n                        perpendicularStack[i].x +\r\n                        polygonB.vtx[j].y *\r\n                        perpendicularStack[i].y;\r\n                if(bmax === null || dot > bmax){\r\n                    bmax = dot;\r\n                }\r\n                if(bmin === null || dot < bmin){\r\n                    bmin = dot;\r\n                }\r\n            }\r\n            if((amin < bmax && amin > bmin) ||\r\n                (bmin < amax && bmin > amin)){\r\n                continue;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n        \r\n        \r\n    }\r\n\r\n}\r\nfunction circleIntersect(x1, y1, r1, x2, y2, r2) {\r\n\r\n    // Calculate the distance between the two circles\r\n    let CircleDistance = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\r\n\r\n    // When the distance is smaller or equal to the sum\r\n    // of the two radius, the circles touch or overlap\r\n    return CircleDistance <= ((r1 + r2) * (r1 + r2))\r\n}\r\nfunction detectEdgeCollisions() {\r\n    let obj;\r\n    let obj2;\r\n   \r\n        obj = circle;\r\n        \r\n         // Check for left and right\r\n         if (obj.vtx.x < obj.radius){\r\n            obj.vx = Math.abs(obj.vx) * restitution;\r\n            obj.vtx.x = obj.radius;\r\n        }else if (obj.vtx.x > canvasWidth - obj.radius){\r\n            obj.vx = -Math.abs(obj.vx) * restitution;\r\n            obj.vtx.x = canvasWidth - obj.radius;\r\n        }\r\n\r\n        // Check for bottom and top\r\n        if (obj.vtx.y < obj.radius){\r\n            obj.vy = Math.abs(obj.vy) * restitution;\r\n            obj.vtx.y = obj.radius;\r\n        } else if (obj.vtx.y > canvasHeight - obj.radius){\r\n            obj.vy = -Math.abs(obj.vy) * restitution;\r\n            obj.vtx.y = canvasHeight - obj.radius;\r\n        }\r\n        for (let i = 0; i < polygonsObjects.length; i++) {\r\n            obj2 = polygonsObjects[i];\r\n            // console.log(obj2.min);\r\n            // console.log(obj2.max)\r\n            // Check for left and right\r\n            if (obj2.min.x <0) {\r\n                obj2.vx = Math.abs(obj2.vx) * restitution;\r\n                // obj.x = obj.radius;\r\n            }else if (obj2.max.x > canvasWidth ){\r\n                obj2.vx = -Math.abs(obj2.vx) * restitution;\r\n            \r\n            }\r\n\r\n            // Check for bottom and top\r\n            if (obj2.min.y < 0) {\r\n                obj2.vy = Math.abs(obj2.vy) * restitution;\r\n                \r\n            }else if (obj2.max.y > canvasHeight ){\r\n                obj2.vy = -Math.abs(obj2.vy) * restitution;\r\n                \r\n            }\r\n        }\r\n        \r\n\r\n    \r\n}\r\n\r\nfunction polyPoly(p1 = [], p2 = []) {\r\n    // go through each of the vertices, plus the next\r\n  // vertex in the list\r\n  let next = 0;\r\n  for (let current=0; current<p1.length; current++) {\r\n\r\n    // get next vertex in list\r\n    // if we've hit the end, wrap around to 0\r\n    next = current+1;\r\n    if (next == p1.length) next = 0;\r\n\r\n    // get the PVectors at our current position\r\n    // this makes our if statement a little cleaner\r\n    let vc = p1[current];    // c for \"current\"\r\n    let vn = p1[next];       // n for \"next\"\r\n\r\n    // now we can use these two points (a line) to compare\r\n    // to the other polygon's vertices using polyLine()\r\n   \r\n    if (polyLine(p2, vc.x,vc.y,vn.x,vn.y)) {\r\n        return true;\r\n    }\r\n    // // optional: check if the 2nd polygon is INSIDE the first\r\n    // collision = polyPoint(p1, p2[0].x, p2[0].y);\r\n    // if (collision) return true;\r\n  }\r\n\r\n  return false;\r\n}\r\nfunction polyLine(vertices = [], x1,  y1, x2, y2) {\r\n   next = 0;\r\n  for (let current=0; current<vertices.length; current++) {\r\n\r\n    // get next vertex in list\r\n    // if we've hit the end, wrap around to 0\r\n    next = current+1;\r\n    if (next == vertices.length) next = 0;\r\n\r\n    // get the PVectors at our current position\r\n    // extract X/Y coordinates from each\r\n    let x3 = vertices[current].x;\r\n     let y3 = vertices[current].y;\r\n    let x4 = vertices[next].x;\r\n    let y4 = vertices[next].y;\r\n\r\n    // do a Line/Line comparison\r\n    // if true, return 'true' immediately and\r\n    // stop testing (faster)\r\n    if (lineLine(x1, y1, x2, y2, x3, y3, x4, y4)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // never got a hit\r\n  return false;\r\n}\r\nfunction lineLine( x1, y1, x2, y2, x3, y3, x4, y4) {\r\n    let uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));\r\n    let uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));\r\n\r\n  // if uA and uB are between 0-1, lines are colliding\r\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction findG(vertex){\r\n    let tongX =0 ;\r\n    let tongY =0;\r\n    let tong=0 ;\r\n    let tamX;\r\n    let tamY;\r\n    let tamS;\r\n    for (let i = 1; i < vertex.length-1; i++) {\r\n        tamX = xAG(vertex[0], vertex[i], vertex[i+1]);\r\n        tamY = yAG(vertex[0], vertex[i], vertex[i+1]);\r\n        tamS = sA(vertex[0], vertex[i], vertex[i+1]);\r\n        tongX += (tamX * tamS);\r\n        tongY += (tamY * tamS);\r\n        tong += tamS;\r\n      \r\n    }\r\n    let xG = tongX/tong;\r\n    let yG = tongY/tong;\r\n    pointG.x = xG;\r\n    pointG.y = yG;\r\n    \r\n    return pointG;\r\n}\r\nfunction xAG(vertexA, vertexB, vertexC) {\r\n    return (vertexA.x + vertexB.x +vertexC.x)/3;\r\n}\r\nfunction yAG(vertexA, vertexB, vertexC) {\r\n    return (vertexA.y + vertexB.y +vertexC.y)/3;\r\n}\r\nfunction sA(vertexA, vertexB, vertexC) {\r\n    let tam;\r\n    tam = (vertexA.x - vertexB.x) *(vertexA.y + vertexB.y) \r\n    + (vertexB.x - vertexC.x) * (vertexB.y + vertexC.y) +\r\n    (vertexC.x - vertexA.x) * (vertexC.y + vertexA.y);\r\n\r\n    return Math.abs(tam)/2;\r\n}\n\n//# sourceURL=webpack://newcollision/./function.js?");

/***/ }),

/***/ "./gameObject.js":
/*!***********************!*\
  !*** ./gameObject.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameObjectNew\": () => (/* binding */ GameObjectNew)\n/* harmony export */ });\n/* harmony import */ var _coordinates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coordinates */ \"./coordinates.js\");\n\r\nclass GameObjectNew {\r\n    constructor (context, coordinates = new _coordinates__WEBPACK_IMPORTED_MODULE_0__.Coordinates(0, 0), vx, vy, radius){\r\n        this.context = context;\r\n\r\n        this.vx = vx;\r\n        this.vy = vy;\r\n        this.coordinates = coordinates;\r\n        this.isColliding = false;\r\n        this.radius= radius;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://newcollision/./gameObject.js?");

/***/ }),

/***/ "./polygons.js":
/*!*********************!*\
  !*** ./polygons.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Polygons\": () => (/* binding */ Polygons)\n/* harmony export */ });\n/* harmony import */ var _gameObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gameObject */ \"./gameObject.js\");\n/* harmony import */ var _coordinates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./coordinates */ \"./coordinates.js\");\n\r\n\r\nclass Polygons extends _gameObject__WEBPACK_IMPORTED_MODULE_0__.GameObjectNew {\r\n    constructor(context, vtx= [] , vx, vy) {\r\n        super();\r\n       this.context = context;\r\n       this.vx = vx;\r\n       this.vy=vy;\r\n        this.vtx= vtx;\r\n        this.edge = [];\r\n        this.setEdge();\r\n        this.min = new _coordinates__WEBPACK_IMPORTED_MODULE_1__.Coordinates(0,0);\r\n        this.max = new _coordinates__WEBPACK_IMPORTED_MODULE_1__.Coordinates(0,0);\r\n        this.findMaxMin();\r\n        this.G = new _coordinates__WEBPACK_IMPORTED_MODULE_1__.Coordinates(0,0);\r\n        this.lineX = 0;\r\n        this.lineY = 0;\r\n    }\r\n    findMaxMin(){\r\n        let minX = this.vtx[0].x;\r\n        let minY = this.vtx[0].y;\r\n        let maxX = this.vtx[0].x;\r\n        let maxY = this.vtx[0].y;\r\n        for (let i = 1; i < this.vtx.length; i++) {\r\n            if (minX > this.vtx[i].x)\r\n            {\r\n                minX = this.vtx[i].x;\r\n            }\r\n            if (minY> this.vtx[i].y)\r\n            {\r\n                minY = this.vtx[i].y;\r\n            }\r\n            if (maxX < this.vtx[i].x)\r\n            {\r\n                maxX = this.vtx[i].x;\r\n            }\r\n            if (maxY < this.vtx[i].y)\r\n            {\r\n                maxY = this.vtx[i].y;\r\n            } \r\n            \r\n        }\r\n        this.min.x = minX;\r\n        this.min.y = minY;\r\n        this.max.x = maxX;\r\n        this.max.y = maxY;\r\n    }\r\n    \r\n\r\n    setEdge(){\r\n        for (let i = 1; i < this.vtx.length; i++) {\r\n            this.edge.push( new _coordinates__WEBPACK_IMPORTED_MODULE_1__.Coordinates(this.vtx[i].x -this.vtx[i-1].x, this.vtx[i].y -this.vtx[i-1].y ))\r\n        }\r\n        var lastVtx = this.vtx.length-1;\r\n        this.edge.push( new _coordinates__WEBPACK_IMPORTED_MODULE_1__.Coordinates(this.vtx[lastVtx].x -this.vtx[0].x, this.vtx[lastVtx].y -this.vtx[0].y ))\r\n    }\r\n    draw(){\r\n        this.context.beginPath();\r\n        this.context.moveTo(this.vtx[0].x, this.vtx[0].y)\r\n        for (let i = 1; i < this.vtx.length; i++) {\r\n            this.context.lineTo(this.vtx[i].x,  this.vtx[i].y)\r\n        }\r\n        this.context.fillStyle = this.isColliding?'#ff8080':'#0099b0';\r\n        this.context.fill();\r\n        this.context.beginPath();\r\n        this.context.moveTo(this.G.x, this.G.y);\r\n        this.context.lineTo(this.lineX, this.lineY );\r\n        this.context.stroke();\r\n    }\r\n    update(secondsPassed, pointG){\r\n        for (let key in this.vtx) {\r\n            this.vtx[key].x += this.vx * secondsPassed;\r\n            this.vtx[key].y += this.vy * secondsPassed;\r\n        }\r\n\r\n        let radians = Math.atan2(this.vy, this.vx);\r\n        \r\n        \r\n\r\n        this.G.x = pointG.x;\r\n        this.G.y = pointG.y;\r\n        this.lineY = this.G.y + (Math.sin(radians) * 30);\r\n        this.lineX = this.G.x + (Math.cos(radians) * 30);\r\n        this.findMaxMin();\r\n        this.isColliding = false;\r\n    }\r\n    clearCanvas(){\r\n        this.context.clearRect(0, 0, 500, 500);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://newcollision/./polygons.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./function.js");
/******/ 	
/******/ })()
;